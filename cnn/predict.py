import argparseimport torchfrom cnn.model import CNN_mnistfrom cnn.linear_model import Linear_mnistfrom PIL import Image, ImageOpsimport torchvision.transforms as transforms# from pillow import convert_imgdef load_img(input_img):    pil_img = Image.open(input_img)    is_wh_same = False    if pil_img.width != pil_img.height:        is_wh_same = True    if pil_img.mode == 'RGBA':        print('Image Mode is RGBA')        rgb_img = Image.new("RGB", pil_img.size, (255, 255, 255))        rgb_img.paste(pil_img, mask=pil_img.split()[3])    else:        rgb_img = pil_img    # import pdb; pdb.set_trace()    inverted_img = ImageOps.invert(rgb_img)    inverted_img = inverted_img.resize((28, 28)).convert("L")    if is_wh_same:        inverted_img = inverted_img.rotate(270)    input = transforms.ToTensor()(            inverted_img            ).unsqueeze(0)    return inputdef predict(input_img, model):    if model == 'cnn':        param = torch.load('cnn/mnist_model.pth')        model = CNN_mnist()        model.load_state_dict(param)    elif model == 'linear':        param = torch.load('cnn/mnist_model_linear.pth')        model = Linear_mnist()        model.load_state_dict(param)    input = load_img(input_img)    # input = convert_img(input_img)    outputs = model(input)    _, predicted = torch.max(outputs, 1)    # print("prediction:", predicted[0].item())    return predicted[0].item()if __name__ == '__main__':    parser = argparse.ArgumentParser(description='predict the number of the input image')    parser.add_argument('--model', type=str, default='cnn', help='specfy the model you want to use')    parser.add_argument('--img_path', type=str, default='./images/IMG_5796.JPG', help='input image path')    args = parser.parse_args()    print(predict(args.img_path, args.model))